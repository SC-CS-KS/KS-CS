# 什么是系统调用？

```md
是为了方便应用使用操作系统的接口，而库函数是为了方便人们编写应用程序而引出的。
可以理解为内核提供给在用户态用的接口函数，可以认为是某种内核的库函数。
read就是系统调用，而 fread 就是C标准库函数。
内核提供的这组系统调用通常也被称之为系统调用接口层。
```
* 系统调用 和 POSIX
```md
操作系统API的主要作用是把操作系统的功能完全展示出来，提供给应用程序，
基于该操作系统，与文件、内存、时钟、网络、图形、各种外设等互操作的能力。
此外，操作系统API通常还提供许多工具类的功能，比如操纵字符串、各种数据类型、时间日期等。
```
```md
在UNIX世界里，最通用的操作系统API基于POSIX（Portable Operating System Interface of UNIX，可移植操作系统接口）标准。
POSIX 的诞生和 UNIX 的发展密不可分。为了解决 UNIX 版本混乱的问题，IEEE 制订了 POSIX 标准，
目标是提供一套大体上基于UNIX的可移植操作系统标准，提高UNIX环境下应用程序的可移植性。
然而，POSIX 并不局限于 UNIX。许多其他的操作系统，例如DEC OpenVMS 和Microsoft Windows NT，都支持 POSIX 标准。
```
```md
POSIX标准定义了"POSIX兼容"的操作系统所必须提供的服务。
Linux 兼容于 POSIX标准，提供了根据 POSIX 而定义的 API 函数。
这些API函数和系统调用之间有着直接的关系，一个API函数可以由一个系统调用实现，也可以通过调用多个系统调用来实现，还可以完全不使用任何系统调用。
```
* 系统调用和C库
```md
操作系统 API 通常都以C库的方式提供，Linux也是如此。
C库提供了 POSIX 的绝大部分 API，同时，内核提供的每个系统调用在C库中都具有相应的封装函数。
系统调用与其C库封装函数的名称常常相同，比如，read 系统调用在 C 库中的封装函数即为 read函数。
```
```md
C库中的系统调用封装函数在最终调用到相应系统调用之前，往往不做多少额外的工作。
不过，某些情况下会有些例外，比如对于两个相关的系统调用 truncate和 truncate64，C库中的封装函数 truncate 函数即需要决定它们中的哪个应该最终被调用。
```
```md
系统调用和C库函数之间并不是一一对应的关系。
可能几个不同的函数会调用到同一个系统调用，比如 malloc 函数和 free 函数都是通过 brk 系统调用来扩大或缩小进程的堆栈，
execl、execlp、execle、execv、execvp和execve函数都是通过 execve 系统调用来执行一个可执行文件。

有可能一个函数调用多个系统调用。更有些函数并不依赖于任何系统调用，
比如 strcpy函数（复制字符串）和 atoi函数（转换ASCII为整数），因为它们并不需要向内核请求任何服务。
```
```md
实际上，从用户的角度看，系统调用和C库之间的区别并不重要，他们只需通过C库函数完成所需功能。
相反，从内核的角度看，需要考虑的则是提供哪些针对确定目的的系统调用，并不需要关注它们如何被使用。
```
* 系统调用与系统命令
```md
系统命令位于C库的更上层，是利用C库实现的可执行程序，比如最为常用的ls、cd等命令。
strace工具可以跟踪命令的执行，使用希望跟踪的命令为参数，并显示出该命令执行过程中所使用到的所有系统调用。
比如，如果希望了解在执行pwd命令时都调用了哪些系统调用，可以使用下面的命令：
$strace pwd
```
* 系统调用和内核函数
```md
内核函数与C库函数的区别仅仅是内核函数在内核实现，因此必须遵守内核编程的规则。
系统调用最终必须具有明确的操作。用户应用程序通过系统调用进入内核后，会执行各个系统调用对应的内核函数，
即系统调用服务例程，比如系统调用 getpid 的服务例程是内核函数 sys_getpid。
```
```md
系统调用服务例程之外，内核中存在着大量的内核函数。有些局限于某个内核文件自己使用，有些则是export出来供内核其他部分共同使用。
对于export出来的内核函数，可以通过 /proc/kallsyms 文件查看。
```