# Concurrent Model

## 多线程模式
```md
单位线程完成完整的任务，也即是一条龙服务线程。
```
* 优势
```md
映射现实单一任务，便于理解和编码。
```
* 劣势
```md
有状态多线程共享资源，导致资源竞争，死锁问题，线程等待阻塞，失去并发意义，
有状态多线程非阻塞算法，有利减少竞争，提升性能，但难以实现，
多线程执行顺序无法预知。
```
## 流水线模型
```md
顾名思义就是流水线上有多个环节，每个环节完成自己的工作后就交给下一个环节，无需等待上游，
周而复始的完成自己岗位上的一亩三分地就行。各个环节之间交付无需等待，完成即可交付。

特点是无状态线程，无状态也意味着无需竞争共享资源，无需等待，也就是非阻塞模型。

流水线也不止一条，所以有多条流水线同时工作。
不同岗位的生产效率是不一样的，所以不同流水线之间也可以发生协同。
```
* 响应式模型或者事件驱动模型
```md
流水线模型也称为响应式模型或者事件驱动模型。
其实就是流水线上上游岗位完成生产就通知下游岗位，所以完成了一个事件的通知，每完成一次就通知一下，就是响应式的意思。
```
* 思想
```md
纵向切分任务，把任务里面耗时过久的环节单独隔离出来，避免完成一个任务需要耗费等待的时间。
在实现上又分为Actors和Channels模型。
```
* Actors
* Channels
```md
由于各个环节直接不直接交互，所以上下游之间并不知道对方是谁。

比不同环节直接用的是几条公共的传送带来接收物品，各自只需要把完成后的半成品扔到传送带，
即使后面流水线优化了，去掉中间的环节，对于个体岗位来说也是无感知的，它只是周而复始的从传送带拿物品来加工。
```
* 优势
```md
无共享状态：无需考虑资源抢占，死锁等问题
独享内存：worker可以持有内存，合并多次操作到内存后再持久化，提升效率
贴合底层：单线程模式贴合硬件运行流程，便于代码维护
任务顺序可预知
```
* 劣势
> * 不够直观
```md
有没有办法让我们编码的时候像写传统的多线程代码一样，而运行起来又是流水线模式呢？
如基于Java的Akka/Reator/Vert.x/Play/Qbit框架，或者golang就是为流水线模式而生的并发语言，还有nodeJS等等。
```
* 与多线程
```md
流水线模型背后用的也还是多线程来实现。
传统多线程模式下我们需要小心翼翼来处理跟踪资源共享问题，而流水线模式把以前一个线程做的事情拆成多个，
每一个环节再用一条线程来完成，避免共享，线程直接通过管道传输消息。
```
## 函数式模型
* 与 流水线模型
```md
函数式并行模型类似流水线模型，单一的函数是无状态的，所以避免了资源竞争的复杂度，
同时每个函数类似流水线里面的单一环境，彼此直接通过函数调用传递参数副本，函数之外的数据不会被修改。

函数式模式跟流水线模式相辅相成逐渐成为更为主流的并发架构。
```
