2.2 声明范式 declarative programming —— 目标决定行动
命令式编程是行动导向的（Action-Oriented），因而算法是显性而目标是隐性的；
声明式编程是目标驱动的（Goal-Driven），因而目标是显性而算法是隐性的。

声明式编程由若干规范的声明组成，即一系列的陈述句：‘已知这，求解那’，强调‘做什么’而非‘怎么做’。声明式编程是人脑思维方式的抽象，即利用数理逻辑或既定范式对已知条件进行推理和运算。

声明式编程发轫于人工智能的研究，主要包括函数式编程（functional programming, FP）和逻辑式编程（logic programming, LP）.
函数式编程将计算描述为数学函数的求值，而逻辑式编程通过提供一系列事实和规则来推到或论证结果。

声明式编程让我们重回数学思维：
函数式编程类似代数中的表达式变换和计算，逻辑式编程则类似逻辑推理。
其中的变量也如数学中的一样，是抽象符号而非内存地址。
因此，没有复制运算，不会产生变量被改写的副作用，也不存在内存分配和释放的问题。
简化了代码，也减少了调试。

声明式语言和命令式语言并非泾渭分明，而是相互交叉渗透的。
总的来说，在命令式语言中融入声明式的元素应当是一种趋势，尤其是函数式。

声明式编程重目标、轻过程，专注问题的分析和表达而不致陷入算法的迷宫，其代码也更加简洁清晰、易于修改和维护。从这种意义上说，声明式语言天然地就比命令式语言更高级。
计算机语言发展的前3代基本上都是命令式的，而后两代基本都是声明式的，由此可见一斑。
（命令式是模拟电脑的，声明式是模拟人的）

编程语言的流行程度与其擅长的领域关系密切。
声明式语言——尤其是函数式和逻辑式，擅长基于数理逻辑的应用，如人工智能、符号处理、数据库、编译器等，对基于业务逻辑的，尤其是交互式或事件驱动型的应用就不那么得心应手了。而大多数软件是面向用户的，交互性强、多为事件驱动、业务逻辑千差万别，显然命令式语言在此更有用武之地。

其他声明式编程：
属性导向式编程（attribute-oriented programming）
数据流式语言（dataflow programming）
约束式
标记式、规范式等

命令式语言提倡迭代不鼓励递归。
因为迭代比递归更符合命令式思维，前者贴近机器语言，后者更贴近数学语言。
除尾递归（tail recursion）外，一般递归比迭代的开销（overhead）大。
声明式语言则相反,提倡递归不支持迭代。
就语法而言，它不允许迭代中的循环变量；就视角而言，迭代着眼微观过程而递归着眼宏观规律。

尾递归： 是一种特殊的递归，其递归调用出现在函数的最后一步运算。这类递归很容易通过手工或编译器转化为迭代的形式，以优化性能。

任何语言都难脱命令式和声明式的窠臼（kejiu）。事实上，范式非命令式的编程都可以归为声明式的。
因此命令式、函数式和逻辑式 是最核心的三种范式。

归根结底，编程是寻求一种机制，将制定的输入转化为输出。
3种范式对此提供了截然不同的解决方案：
命令式把程序看做一个自动机，输入是初始状态，输出是最终状态，编程就是设计一系列的指令，通过自动机执行以完成状态转变；
函数式把程序看做一个数学函数，输入是自变量，输出是因变量，编程就是设计一系列的函数，通过表达式变换以完成计算；
逻辑式把程序看做是一个逻辑证明，输入是题设，输出是结论，编程就是设计一些列的命题，通过逻辑推理以完成证明。

范式	程序 		输入 		输出 		程序设计	程序运行
命令式 	自动机 		初始状态 	最终状态 	设计指令	命令执行
函数式 	数学函数	自变量		因变量 		设计函数 	表达式变换
逻辑式 	逻辑证明 	题设 		结论 		设计命题 	逻辑推理
