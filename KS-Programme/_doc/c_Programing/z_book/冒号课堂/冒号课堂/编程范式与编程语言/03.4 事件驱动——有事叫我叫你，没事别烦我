3.4 事件驱动——有事叫我叫你，没事别烦我
同步回调和异步回调都使调用者不再依赖被调用者，将二者从代码上解耦，异步调用更将二者从时间上解耦。
控制反转、依赖反转和依赖注射的主题是控制和依赖，目的是解耦，方法是反转，而实现这一切的关键是抽象接口。
“回调”强调的是行为方式——低层反调高层，而“抽象接口”强调的是实现方式——正式由于接口具有抽象性，低层才能在调用它时无须虑及高层的具体实现。

流程驱动式编程（Flow-Driven Programming），采用主动轮询（polling），行为取决于自身的观察判断，是流程驱动的。
事件驱动式编程（Event-Driven Programming，简称EDP），采用被动等通知，行为取决于外来的突发事件，是事件驱动的。

事件 ： 在软件中，它一般表现为一个程序的某些信息状态上的变化。
基于事件驱动的系统一般提供两类内建事件（built-in event）：
一类是 底层事件（low-level event） 和 原生事件（native event），在用户图形界面（GUI）系统中，这列事件直接由鼠标、键盘等硬件设备触发；
一类是 语义事件（semantic event），一般代表用户的行为逻辑，是若干底层时间的组合。比如鼠标拖放（drag-and-drop）多表示移动被拖放的对象，由鼠标按下、鼠标移动和鼠标释放三个底层事件组成。

用户自定义事件（user-defined event），他们可以是在原有的内建事件基础上进行的包装，也可以是纯粹的虚拟事件（virtual event）。除此之外，编程者不但能定义事件还能产生事件。虽然大部分事件是由外界激发的自然事件（natural event），但有时程序员需要主动激发一些事件，如果模拟用户鼠标点击或键盘输入等，这类事件被称为合成事件（synthetic event）。

消息是Windows内部醉基本的通信方式，事件需要消息来传递，是消息的主要来源。
每当用户触发一个事件，如移动鼠标或敲击键盘，系统都会将其转化为消息并放入相应程序的消息队列（messge queue）中。
在消息循环中，程序通过GetMessage不断地从消息队列中获取消息，经过TranslateMessage预处理后再通过DispatchMessage将消息送交窗口过程WndProc处理。

在软件模块分层中，低层模块为为高层模块提供服务，并且不能依赖高层模块，以保证其可重用性；
通常被调用者（Callee）为调用者（Caller）提供服务，调用者依赖被调者。两相结合，决定了底层模块多为被调用者，高层模块多为调用者。
但低层模块为了追求更强的普适性和可扩展性，有事也有调用高层模块的需求，于是便邀callback前来相助。

好莱坞原则： Don't call us, we'll call you.
经纪公司相当于一个背后运作的软件平台，艺人相当于一个Callback，‘留下你的电话’就是注册callback，‘我会打给你’即使异步调用callback。
‘别打给我’意味着经纪公司处于主导地位，艺人们处于受控状态，这便是控制反转（Inversion of Control，IoC）
一般Library中用到callback只是局部的控制反转，而framework将IoC机制用到全局。
程序员牺牲了对应用程序流程的主导权，换来的是更简洁的代码和更高的生成效率。
如果将编程比作命题作文，不用framework的程序是一张可以自由写作的白纸，Library是作文素材库；
采用framework的程序是一篇成型的作文，作者只须填写空白的词语和段落即可。
控制反转不仅增强了framework在代码和设计上的重用性，还极大地提供了可扩展性。这是因为framework的内部运转机制虽然是封闭的，但也开放了不少与外部相连的扩展接口点，类似插件（plugin）体系。

依赖反转原则（Dependency-Inversion Principle, DIP）相比控制反转更加具体——
高层模块不应依赖低层模块，它们都应该依赖抽象：抽象不应依赖细节，细节应依赖抽象。
依赖注射（Dependency Injection， DI）—— 动态地为一个软件组件提供外部依赖。

可以看出，他们的主题是控制与依赖，目的是解耦，方法是反转，而实现这一切的关键是抽象接口。

回调函数的提法较为古老，多出现于过程式编程，抽象接口是更现代，更OO的说法。
从字面上看，‘回调’强调的是行为方式——低层反调高层，而‘抽象接口’强调实现的方式——正式由于接口的抽象性，低层才能在调用它时，无需虑及高层的具体细节，从而实现控制反转。

事件机制设计需考虑的问题：
事件定义、事件触发、事件侦查、事件转化、事件合并、事件调度、事件传播、事件处理、事件连带（event cascade）等。

软件的可伸缩性（scalability）一般指从容应对工作量增长的能力，常与性能等指标一起被考量。
而控制反转的主要作用是降低模块之间的依赖性，从而降低模块的耦合度和复杂度，提高软件的可重用性、柔韧性和可扩展性，但对可伸缩性并无太大帮助。
控制反转导致事件驱动编程的被动性（passivity），此外，事件驱动还具有异步特征，这是由于事件的不可预测性和随机性决定的。
如果一个应用中，存在一些该类特质的因素，比如频繁的出现堵塞呼叫（blocking call），不妨考虑将其包装为事件。
堵塞呼叫举例：
如在高速上有一辆突然发生故障，如果现场维修，在修好之前所在车道是堵塞的，后面车辆无法通行。类似地，在程序中一些函数须要等待某些数据而不能立即返回，从而堵塞整个进程。
另外一种是将车拖到路边，修完后向其他车辆发出信号，以便重回车道。同理，可以让堵塞呼叫暂时脱离主进程，事成之后再利用事件机制申请重返原进程。这种异步事件式将连续的进程中独立且耗时的部分抽取出来，从而减少随机因素造成的资源浪费，提供系统的性能和可伸缩性。

NOTICE ： 独立是异步的前提，耗时是异步的理由

一个典型的事件驱动模块：
事件处理器事先在关注的事件源上注册，后者不定期地发表事件对象，经过事件管理器的转化（translate）、合并（coalesce）、排队（enquence）、分派（dispatch）等集中处理后，事件处理器接收到事件并对其进行相应的处理。

发行/订阅模式（publish-subscribe pattern）是 观察者模式（observer pattern）的别名，一方面可看作简化或退化的事件驱动式，另一方面可看作事件驱动式的核心思想。
该模式省略了事件管理器部分，由事件源直接调用事件处理器的接口。

总结：
>事件是程序中令人关注的信息状态上的变化，在基于事件驱动的系统中，事件包括内建事件和用户自定义事件，其中内建事件又分为底层事件和语义事件。此外事件还有自然事件和合成事件之分。
>Callback指能作为参数传递的函数或代码，它允许低层模块调用高层模块，使调用者与被调用者从代码上解耦。异步Callback在传入后并不立即被调用，使调用者和被调用者从时间上解耦。
>控制反转一般通过Callback实现，其目的是降低模块之间的依赖，从而降低模块的的耦合度和复杂度。
>控制反转、依赖反转原则和依赖注射是近义词，它们的主题是控制和依赖、目的是解耦、方法是反转，而实现这一切的关键是抽象接口（包括函数指针、抽象类、接口、C++中的泛型函子和C#中的委托）
>事件驱动式编程的3个步骤：实现事件处理器；注册事件处理器；实现事件循环。
>异步过程在主程序中已非堵塞的机制运行，即主程序不必等待该过程的返回就能继续下一步。异步机制能减少随机因素造成的资源浪费，提高系统的性能和可伸缩性。
>独立是异步的前提，耗时是异步的理由。
>事件驱动式最重要的两个特征是被动性和异步性。被动性来之控制反转，异步性来之会话切换。
>观察者模式又名发行/订阅模式，既是事件驱动式的简化，也是事件驱动式的核心思想。MVC架构是观察者模式在架构设计上的一个应用。

注解：
GOF四人组提出MVC模式的主要关系是由Observer（观察者模式）、Composite（组合模式）和Strategy（策略模式）三个设计模式给出的。

MVC模式通过建立一个“发布/订阅”（publish-subscribe）的机制来分离视图和模型。
发布－订阅（publish-subscribe）机制的目标是发布者，它发出通知时并不需知道谁是它的观察者。
可以有任意数目的观察者订阅并接收通知。
MVC模式最重要的是用到了Observer（观察者模式），正是观察者模式实现了发布－订阅（publish-subscribe）机制，实现了视图和模型的分离。因此谈到MVC模式就必须谈到观察者模式。