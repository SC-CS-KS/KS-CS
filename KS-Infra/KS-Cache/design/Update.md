# Cache Update

## Pattern
### Cache Aside Pattern
```md
失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。
命中：应用程序从cache中取数据，取到后返回。
更新：先把数据存到数据库中，成功后，再让缓存失效。
```
* 为什么不是写完数据库后更新缓存？
```md
主要是怕两个并发的写操作导致脏数据。
```
* 会有脏数据问题
```md
比如，一个是读操作，但是没有命中缓存，然后就到数据库中取数据，此时来了一个写操作，写完数据库后，让缓存失效，
然后，之前的那个读操作再把老的数据放进去，所以，会造成脏数据。
```
```md
上述Case理论上会出现，不过，实际上出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。
而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，
又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。
```
* 如何解决
```md
要么通过2PC 或是 Paxos 协议保证一致性，

要么就是拼命的降低并发时脏数据的概率，而Facebook使用了这个降低概率的玩法，
因为2PC太慢，而Paxos太复杂。当然，最好还是为缓存设置上过期时间。
```
* 应用
* [Scaling Memcache at Facebook](https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf)

### Read Through
```md
Read/Write Through套路是把更新数据库（Repository）的操作由缓存自己代理了，所以，对于应用层来说，就简单很多了。
可以理解为，应用认为后端就是一个单一的存储，而存储自己维护自己的Cache。
```
```md
Read Through 套路就是在查询操作中更新缓存，也就是说，当缓存失效的时候（过期或LRU换出），
Cache Aside 是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对应用方是透明的。
```
### Write Through
```md
Write Through 套路和Read Through相仿，不过是在更新数据时发生。
当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。
如果命中了缓存，则更新缓存，然后再由Cache自己更新数据库（这是一个同步操作）。
```
### Write Behind Caching Pattern
```md
Write Behind 又叫 Write Back。类似 Linux 文件系统的 Page Cache 的算法。
```
```md
Write Back套路，一句说就是，在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。
```
* 优势
```md
设计的好处就是让数据的I/O操作飞快无比（因为直接操作内存嘛 ），
因为异步，write backg还可以合并对同一个数据的多次操作，所以性能的提高是相当可观的。
```
* 缺点
```md
数据不是强一致性的，而且可能会丢失（Unix/Linux非正常关机会导致数据丢失，就是因为这个事）
Write Back实现逻辑比较复杂，因为他需要track有哪数据是被更新了的，需要刷到持久层上。
（操作系统的write back会在仅当这个cache需要失效的时候，才会被真正持久起来，比如，内存不够了，或是进程退出了等情况，这又叫lazy write。）
```
