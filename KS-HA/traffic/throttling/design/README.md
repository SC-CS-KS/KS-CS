# Design

## 模式
* 客户端模式
* 服务端模式

## 维度
* 连接数
* 网络流量
* 总QPS
* 分类QPS
* CPU
* 内存

## 算法
* 计数器法
```md
直接记录一下当前周期内的请求个数，如果请求个数超出了阈值，那么就限制请求，如果没有超出，就放行。
```
```md
缺点：
系统限流的QPS为100，第一秒有90个请求，并且所有的请求都在最后100ms进入，这个时候请求没有达到阈值，是不会限流的。
紧接着第二秒也有90个请求，不过全部集中在前100ms进入，这个时候也没有达到阈值，也不会限流。
```
* 固定窗口
* 滑动窗口 - 适用于对异常结果「高容忍」的场景
```md
滑动窗口计数会把计数窗口进行分割，比如分割成两份、10份等，分割的越小，精度越高。
```
```md
假如把统计窗口均分为10等分，假设统计窗口为1秒，那么每一小格代表的就是100ms的请求计数，
最近1秒中的请求总数就等于最近10小格的统计数之和。
每过去100ms，统计窗口就向右滑动一小格（这就是滑动窗口法的由来），
最新的数据记录在最右边位置，最左一格的数据将会被丢弃（具体实现上会有所差异）。
```
```md
其实滑动窗口法并没有完全消除计数器法中遇到的问题，它只是减小了影响。
假设限流 QPS 大小为X，窗口均分为N份，那么理论上可以达到的峰值 QPS 为 X * (N + 1) / N，它显然是大于X的。
不过我们多均分几份以后，影响就会大大减少。
```
* 漏桶 - 最适合作为一个通用方案
```md
固定线程个数的线程池就是我们平时接触的比较多的漏桶法限流的例子，
这种情况中不管需要处理的任务有多少，线程池最多只会运行固定个数的任务，其余的任务要么被拒绝要么等待。
```
* 令牌桶 - 需要尽可能的压榨程序的性能
```md
令牌桶算法就是系统会安装固定的速率往桶中添加令牌，请求的时候先到桶里拿一个令牌，
如果能够拿到令牌就表示可以进行请求处理，如果桶里没有令牌了，就表明需要限流了。
```
